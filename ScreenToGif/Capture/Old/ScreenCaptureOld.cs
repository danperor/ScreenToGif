using ScreenToGif.Domain.Enums;
using ScreenToGif.Domain.Interfaces;
using ScreenToGif.Domain.Models.Project.Recording.Events;
using ScreenToGif.Model;
using ScreenToGif.Util;
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace ScreenToGif.Capture;

internal abstract class ScreenCaptureOld : BaseCaptureOld, IScreenCaptureOld
{
    private FileStream _eventsFileStream;
    private BufferedStream _eventsBufferedStream;
    private Task _eventConsumerTask;
    private BlockingCollection<RecordingEvent> _eventConsumer;

    #region Properties

    public int Left { get; set; }

    public int Top { get; set; }
    
    /// <summary>
    /// The name of the monitor device where the recording is supposed to happen.
    /// </summary>
    public string DeviceName { get; set; }

    public bool WasEventCaptureStarted { get; set; }

    public bool IsAcceptingEvents { get; set; }

    #endregion

    public virtual void Start(int delay, int left, int top, int width, int height, double scale, ProjectInfo project)
    {
        base.Start(delay, width, height, scale, project);

        Left = left;
        Top = top;

        _eventsFileStream = new FileStream(project.EventsPath, FileMode.Create, FileAccess.Write, FileShare.None);
        _eventsBufferedStream = new BufferedStream(_eventsFileStream, 10 * 1048576); //Each 1 MB has 1_048_576 bytes.

        ConfigureEventConsumer();

        WasEventCaptureStarted = true;
        IsAcceptingEvents = true;
    }

    private void ConfigureEventConsumer()
    {
        _eventConsumer ??= new BlockingCollection<RecordingEvent>();

        //Spin up a Task to consume the events generated by the recorder.
        _eventConsumerTask = Task.Factory.StartNew(() =>
        {
            try
            {
                while (true)
                {
                    var recordingEvent = _eventConsumer.Take();
                }
            }
            catch (InvalidOperationException)
            {
                //It means that Take() was called on a completed collection.
            }
            catch (Exception e)
            {
                Application.Current.Dispatcher.Invoke(() => OnError?.Invoke(e));
            }
        });
    }


    public abstract int CaptureWithCursor(FrameInfo frame);

    public abstract Task<int> CaptureWithCursorAsync(FrameInfo frame);

    public virtual int ManualCapture(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursor(frame) : Capture(frame);
    }

    public virtual Task<int> ManualCaptureAsync(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursorAsync(frame) : CaptureAsync(frame);
    }


    public override async Task Stop()
    {
        await base.Stop();

        if (!WasEventCaptureStarted)
            return;

        IsAcceptingEvents = false;

        //Stop the consumer thread.
        _eventConsumer.CompleteAdding();

        await _eventConsumerTask;

        //Finishing writing the events to the cache.
        await _eventsBufferedStream.FlushAsync();
        await _eventsFileStream.FlushAsync();

        await _eventsBufferedStream.DisposeAsync();
        await _eventsFileStream.DisposeAsync();

        WasEventCaptureStarted = false;
    }

    internal override async Task DisposeInternal()
    {
        await base.DisposeInternal();

        _eventConsumerTask?.Dispose();
        _eventConsumerTask = null;

        _eventConsumer?.Dispose();
        _eventConsumer = null;
    }
}